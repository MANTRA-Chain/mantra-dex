{
  "contract_name": "farm-manager",
  "contract_version": "2.0.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "description": "The instantiation message",
    "type": "object",
    "required": [
      "create_farm_fee",
      "emergency_unlock_penalty",
      "epoch_manager_addr",
      "farm_expiration_time",
      "fee_collector_addr",
      "max_concurrent_farms",
      "max_farm_epoch_buffer",
      "max_unlocking_duration",
      "min_unlocking_duration",
      "owner",
      "pool_manager_addr"
    ],
    "properties": {
      "create_farm_fee": {
        "description": "The fee that must be paid to create a farm.",
        "allOf": [
          {
            "$ref": "#/definitions/Coin"
          }
        ]
      },
      "emergency_unlock_penalty": {
        "description": "The penalty for unlocking a position before the unlocking duration finishes. In percentage.",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal"
          }
        ]
      },
      "epoch_manager_addr": {
        "description": "The epoch manager address, where the epochs are managed",
        "type": "string"
      },
      "farm_expiration_time": {
        "description": "The amount of time after which a farm is considered to be expired after it ended. In seconds. Once a farm is expired it cannot be expanded, and expired farms can be closed",
        "type": "integer",
        "format": "uint64",
        "minimum": 0.0
      },
      "fee_collector_addr": {
        "description": "The fee collector address, where protocol fees are stored",
        "type": "string"
      },
      "max_concurrent_farms": {
        "description": "The maximum amount of farms that can exist for a single LP token at a time.",
        "type": "integer",
        "format": "uint32",
        "minimum": 0.0
      },
      "max_farm_epoch_buffer": {
        "description": "New farms are allowed to start up to `current_epoch + start_epoch_buffer` into the future.",
        "type": "integer",
        "format": "uint32",
        "minimum": 0.0
      },
      "max_unlocking_duration": {
        "description": "The maximum amount of time that a user can lock their tokens for. In seconds.",
        "type": "integer",
        "format": "uint64",
        "minimum": 0.0
      },
      "min_unlocking_duration": {
        "description": "The minimum amount of time that a user can lock their tokens for. In seconds.",
        "type": "integer",
        "format": "uint64",
        "minimum": 0.0
      },
      "owner": {
        "description": "The owner of the contract",
        "type": "string"
      },
      "pool_manager_addr": {
        "description": "The pool manager address, where pools are created",
        "type": "string"
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "description": "The execution messages",
    "oneOf": [
      {
        "description": "Manages a farm based on the action, which can be: - Fill: Creates or expands a farm. - Close: Closes an existing farm.",
        "type": "object",
        "required": [
          "manage_farm"
        ],
        "properties": {
          "manage_farm": {
            "type": "object",
            "required": [
              "action"
            ],
            "properties": {
              "action": {
                "$ref": "#/definitions/FarmAction"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Manages a position based on the action, which can be: - Fill: Creates or expands a position. - Close: Closes an existing position.",
        "type": "object",
        "required": [
          "manage_position"
        ],
        "properties": {
          "manage_position": {
            "type": "object",
            "required": [
              "action"
            ],
            "properties": {
              "action": {
                "$ref": "#/definitions/PositionAction"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Claims the rewards for the user",
        "type": "object",
        "required": [
          "claim"
        ],
        "properties": {
          "claim": {
            "type": "object",
            "properties": {
              "until_epoch": {
                "description": "The epoch until which the rewards should be claimed. If none is provided, it will claim until the current epoch.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Updates the config of the contract",
        "type": "object",
        "required": [
          "update_config"
        ],
        "properties": {
          "update_config": {
            "type": "object",
            "properties": {
              "create_farm_fee": {
                "description": "The fee that must be paid to create a farm.",
                "anyOf": [
                  {
                    "$ref": "#/definitions/Coin"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "emergency_unlock_penalty": {
                "description": "The penalty for unlocking a position before the unlocking duration finishes. In percentage.",
                "anyOf": [
                  {
                    "$ref": "#/definitions/Decimal"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "epoch_manager_addr": {
                "description": "The epoch manager address, where the epochs are managed",
                "type": [
                  "string",
                  "null"
                ]
              },
              "farm_expiration_time": {
                "description": "The amount of time after which a farm is considered to be expired after it ended. In seconds. Once a farm is expired it cannot be expanded, and expired farms can be closed",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              },
              "fee_collector_addr": {
                "description": "The fee collector address, where protocol fees are stored",
                "type": [
                  "string",
                  "null"
                ]
              },
              "max_concurrent_farms": {
                "description": "The maximum amount of farms that can exist for a single LP token at a time.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "max_farm_epoch_buffer": {
                "description": "The maximum amount of epochs in the future a new farm is allowed to start in.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "max_unlocking_duration": {
                "description": "The maximum amount of time that a user can lock their tokens for. In seconds.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              },
              "min_unlocking_duration": {
                "description": "The minimum amount of time that a user can lock their tokens for. In seconds.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              },
              "pool_manager_addr": {
                "description": "The pool manager address, where pools are created",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Update the contract's ownership. The `action` to be provided can be either to propose transferring ownership to an account, accept a pending ownership transfer, or renounce the ownership permanently.",
        "type": "object",
        "required": [
          "update_ownership"
        ],
        "properties": {
          "update_ownership": {
            "$ref": "#/definitions/Action"
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Action": {
        "description": "Actions that can be taken to alter the contract's ownership",
        "oneOf": [
          {
            "description": "Propose to transfer the contract's ownership to another account, optionally with an expiry time.\n\nCan only be called by the contract's current owner.\n\nAny existing pending ownership transfer is overwritten.",
            "type": "object",
            "required": [
              "transfer_ownership"
            ],
            "properties": {
              "transfer_ownership": {
                "type": "object",
                "required": [
                  "new_owner"
                ],
                "properties": {
                  "expiry": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Expiration"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "new_owner": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Accept the pending ownership transfer.\n\nCan only be called by the pending owner.",
            "type": "string",
            "enum": [
              "accept_ownership"
            ]
          },
          {
            "description": "Give up the contract's ownership and the possibility of appointing a new owner.\n\nCan only be invoked by the contract's current owner.\n\nAny existing pending ownership transfer is canceled.",
            "type": "string",
            "enum": [
              "renounce_ownership"
            ]
          }
        ]
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "Curve": {
        "oneOf": [
          {
            "description": "A linear curve that releases assets uniformly over time.",
            "type": "string",
            "enum": [
              "linear"
            ]
          }
        ]
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "Expiration": {
        "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
        "oneOf": [
          {
            "description": "AtHeight will expire when `env.block.height` >= height",
            "type": "object",
            "required": [
              "at_height"
            ],
            "properties": {
              "at_height": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          },
          {
            "description": "AtTime will expire when `env.block.time` >= time",
            "type": "object",
            "required": [
              "at_time"
            ],
            "properties": {
              "at_time": {
                "$ref": "#/definitions/Timestamp"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Never will never expire. Used to express the empty variant",
            "type": "object",
            "required": [
              "never"
            ],
            "properties": {
              "never": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "FarmAction": {
        "oneOf": [
          {
            "description": "Creates a new farm with the given parameters.",
            "type": "object",
            "required": [
              "create"
            ],
            "properties": {
              "create": {
                "type": "object",
                "required": [
                  "params"
                ],
                "properties": {
                  "params": {
                    "description": "The parameters for the farm to create.",
                    "allOf": [
                      {
                        "$ref": "#/definitions/FarmParams"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Expands an existing farm. The farm must already exist and the sender must be the farm owner. The farm_identifier must be provided in the params.",
            "type": "object",
            "required": [
              "expand"
            ],
            "properties": {
              "expand": {
                "type": "object",
                "required": [
                  "params"
                ],
                "properties": {
                  "params": {
                    "description": "The parameters for the farm to expand.",
                    "allOf": [
                      {
                        "$ref": "#/definitions/FarmParams"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "close"
            ],
            "properties": {
              "close": {
                "type": "object",
                "required": [
                  "farm_identifier"
                ],
                "properties": {
                  "farm_identifier": {
                    "description": "The farm identifier to close.",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "FarmParams": {
        "description": "Parameters for creating farms",
        "type": "object",
        "required": [
          "farm_asset",
          "lp_denom"
        ],
        "properties": {
          "curve": {
            "description": "The type of distribution curve. If unspecified, the distribution will be linear.",
            "anyOf": [
              {
                "$ref": "#/definitions/Curve"
              },
              {
                "type": "null"
              }
            ]
          },
          "farm_asset": {
            "description": "The asset to be distributed in this farm.",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          },
          "farm_identifier": {
            "description": "If set, it  will be used to identify the farm.",
            "type": [
              "string",
              "null"
            ]
          },
          "lp_denom": {
            "description": "The LP asset denom to create the farm for.",
            "type": "string"
          },
          "preliminary_end_epoch": {
            "description": "The epoch at which the farm should preliminarily end (if it's not expanded). If unspecified, the farm will default to end at 14 epochs from the current one.",
            "type": [
              "integer",
              "null"
            ],
            "format": "uint64",
            "minimum": 0.0
          },
          "start_epoch": {
            "description": "The epoch at which the farm will start. If unspecified, it will start at the current epoch.",
            "type": [
              "integer",
              "null"
            ],
            "format": "uint64",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      },
      "PositionAction": {
        "oneOf": [
          {
            "description": "Creates a position.",
            "type": "object",
            "required": [
              "create"
            ],
            "properties": {
              "create": {
                "type": "object",
                "required": [
                  "unlocking_duration"
                ],
                "properties": {
                  "identifier": {
                    "description": "The identifier of the position.",
                    "type": [
                      "string",
                      "null"
                    ]
                  },
                  "receiver": {
                    "description": "The receiver for the position. If left empty, defaults to the message sender.",
                    "type": [
                      "string",
                      "null"
                    ]
                  },
                  "unlocking_duration": {
                    "description": "The time it takes in seconds to unlock this position. This is used to identify the position to fill.",
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Expands a position.",
            "type": "object",
            "required": [
              "expand"
            ],
            "properties": {
              "expand": {
                "type": "object",
                "required": [
                  "identifier"
                ],
                "properties": {
                  "identifier": {
                    "description": "The identifier of the position.",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Closes an existing position. The position stops earning farm rewards.",
            "type": "object",
            "required": [
              "close"
            ],
            "properties": {
              "close": {
                "type": "object",
                "required": [
                  "identifier"
                ],
                "properties": {
                  "identifier": {
                    "description": "The identifier of the position.",
                    "type": "string"
                  },
                  "lp_asset": {
                    "description": "The asset to add to the position. If not set, the position will be closed in full. If not, it could be partially closed.",
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Coin"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Withdraws the LP tokens from a position after the position has been closed and the unlocking duration has passed.",
            "type": "object",
            "required": [
              "withdraw"
            ],
            "properties": {
              "withdraw": {
                "type": "object",
                "required": [
                  "identifier"
                ],
                "properties": {
                  "emergency_unlock": {
                    "description": "Whether to unlock the position in an emergency. If set to true, the position will be unlocked immediately. If the position has not expired, it will pay a penalty.",
                    "type": [
                      "boolean",
                      "null"
                    ]
                  },
                  "identifier": {
                    "description": "The identifier of the position.",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Timestamp": {
        "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
        "allOf": [
          {
            "$ref": "#/definitions/Uint64"
          }
        ]
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "description": "The query messages",
    "oneOf": [
      {
        "description": "Retrieves the configuration of the manager.",
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Retrieves farms in the contract. It is possible to filter by [FarmsBy] and to paginate the results.",
        "type": "object",
        "required": [
          "farms"
        ],
        "properties": {
          "farms": {
            "type": "object",
            "properties": {
              "filter_by": {
                "description": "An optional parameter specifying what to filter farms by. Can be either the farm identifier, lp denom or the farm asset.",
                "anyOf": [
                  {
                    "$ref": "#/definitions/FarmsBy"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "limit": {
                "description": "The amount of farms to return. If unspecified, will default to a value specified by the contract.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "An optional parameter specifying what farm (identifier) to start searching after.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Retrieves the positions for an address.",
        "type": "object",
        "required": [
          "positions"
        ],
        "properties": {
          "positions": {
            "type": "object",
            "properties": {
              "filter_by": {
                "description": "An optional parameter specifying what to filter positions by.",
                "anyOf": [
                  {
                    "$ref": "#/definitions/PositionsBy"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "limit": {
                "description": "The amount of positions to return. If unspecified, will default to a value specified by the contract.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "open_state": {
                "description": "An optional parameter specifying to return only positions that match the given open state. if true, it will return open positions. If false, it will return closed positions.",
                "type": [
                  "boolean",
                  "null"
                ]
              },
              "start_after": {
                "description": "An optional parameter specifying what position (identifier) to start searching after.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Retrieves the rewards for an address.",
        "type": "object",
        "required": [
          "rewards"
        ],
        "properties": {
          "rewards": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "description": "The address to get all the farm rewards for.",
                "type": "string"
              },
              "until_epoch": {
                "description": "The epoch until which the rewards should be queried. If none is provided, it will query until the current epoch.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Retrieves the total LP weight in the contract for a given denom on a given epoch.",
        "type": "object",
        "required": [
          "lp_weight"
        ],
        "properties": {
          "lp_weight": {
            "type": "object",
            "required": [
              "address",
              "denom",
              "epoch_id"
            ],
            "properties": {
              "address": {
                "description": "The address to get the LP weight for.",
                "type": "string"
              },
              "denom": {
                "description": "The denom to get the total LP weight for.",
                "type": "string"
              },
              "epoch_id": {
                "description": "The epoch id to get the LP weight for.",
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Query the contract's ownership information",
        "type": "object",
        "required": [
          "ownership"
        ],
        "properties": {
          "ownership": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "FarmsBy": {
        "description": "Enum to filter farms by identifier, lp denom or the farm asset. Used in the farms query.",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "identifier"
            ],
            "properties": {
              "identifier": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "lp_denom"
            ],
            "properties": {
              "lp_denom": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "farm_asset"
            ],
            "properties": {
              "farm_asset": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "PositionsBy": {
        "description": "Enum to filter positions by identifier or receiver. Used in the positions query.",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "identifier"
            ],
            "properties": {
              "identifier": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "receiver"
            ],
            "properties": {
              "receiver": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        ]
      }
    }
  },
  "migrate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "MigrateMsg",
    "description": "The migrate message",
    "type": "object",
    "additionalProperties": false
  },
  "sudo": null,
  "responses": {
    "config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Config",
      "description": "Configuration for the contract (manager)",
      "type": "object",
      "required": [
        "create_farm_fee",
        "emergency_unlock_penalty",
        "epoch_manager_addr",
        "farm_expiration_time",
        "fee_collector_addr",
        "max_concurrent_farms",
        "max_farm_epoch_buffer",
        "max_unlocking_duration",
        "min_unlocking_duration",
        "pool_manager_addr"
      ],
      "properties": {
        "create_farm_fee": {
          "description": "The fee that must be paid to create a farm.",
          "allOf": [
            {
              "$ref": "#/definitions/Coin"
            }
          ]
        },
        "emergency_unlock_penalty": {
          "description": "The penalty for unlocking a position before the unlocking duration finishes. In percentage.",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "epoch_manager_addr": {
          "description": "The epoch manager address, where the epochs are managed",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "farm_expiration_time": {
          "description": "The amount of time after which a farm is considered to be expired after it ended. In seconds. Once a farm is expired it cannot be expanded, and expired farms can be closed",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "fee_collector_addr": {
          "description": "The fee collector address, where protocol fees are stored",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "max_concurrent_farms": {
          "description": "The maximum amount of farms that can exist for a single LP token at a time.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "max_farm_epoch_buffer": {
          "description": "The maximum amount of epochs in the future a new farm is allowed to start in.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "max_unlocking_duration": {
          "description": "The maximum amount of time that a user can lock their tokens for. In seconds.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "min_unlocking_duration": {
          "description": "The minimum amount of time that a user can lock their tokens for. In seconds.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "pool_manager_addr": {
          "description": "The pool manager address, where pools are created",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "farms": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "FarmsResponse",
      "description": "The response for the farms query",
      "type": "object",
      "required": [
        "farms"
      ],
      "properties": {
        "farms": {
          "description": "The list of farms",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Farm"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Curve": {
          "oneOf": [
            {
              "description": "A linear curve that releases assets uniformly over time.",
              "type": "string",
              "enum": [
                "linear"
              ]
            }
          ]
        },
        "Farm": {
          "description": "Represents a farm.",
          "type": "object",
          "required": [
            "claimed_amount",
            "curve",
            "emission_rate",
            "farm_asset",
            "identifier",
            "lp_denom",
            "owner",
            "preliminary_end_epoch",
            "start_epoch"
          ],
          "properties": {
            "claimed_amount": {
              "description": "The amount of the `farm_asset` that has been claimed so far.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "curve": {
              "description": "The type of curve the farm has.",
              "allOf": [
                {
                  "$ref": "#/definitions/Curve"
                }
              ]
            },
            "emission_rate": {
              "description": "The amount of the `farm_asset` that is to be distributed every epoch.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "farm_asset": {
              "description": "The asset the farm was created to distribute.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "identifier": {
              "description": "The ID of the farm.",
              "type": "string"
            },
            "lp_denom": {
              "description": "The LP asset denom to create the farm for.",
              "type": "string"
            },
            "owner": {
              "description": "The account which opened the farm and can manage it.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "preliminary_end_epoch": {
              "description": "The epoch at which the farm will preliminary end (in case it's not expanded).",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "start_epoch": {
              "description": "The epoch at which the farm starts.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "lp_weight": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "LpWeightResponse",
      "description": "The response for the LP weight query",
      "type": "object",
      "required": [
        "epoch_id",
        "lp_weight"
      ],
      "properties": {
        "epoch_id": {
          "description": "The epoch id corresponding to the lp weight in the contract",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "lp_weight": {
          "description": "The total lp weight in the contract",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "ownership": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Ownership_for_String",
      "description": "The contract's ownership info",
      "type": "object",
      "properties": {
        "owner": {
          "description": "The contract's current owner. `None` if the ownership has been renounced.",
          "type": [
            "string",
            "null"
          ]
        },
        "pending_expiry": {
          "description": "The deadline for the pending owner to accept the ownership. `None` if there isn't a pending ownership transfer, or if a transfer exists and it doesn't have a deadline.",
          "anyOf": [
            {
              "$ref": "#/definitions/Expiration"
            },
            {
              "type": "null"
            }
          ]
        },
        "pending_owner": {
          "description": "The account who has been proposed to take over the ownership. `None` if there isn't a pending ownership transfer.",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Expiration": {
          "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
          "oneOf": [
            {
              "description": "AtHeight will expire when `env.block.height` >= height",
              "type": "object",
              "required": [
                "at_height"
              ],
              "properties": {
                "at_height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "AtTime will expire when `env.block.time` >= time",
              "type": "object",
              "required": [
                "at_time"
              ],
              "properties": {
                "at_time": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Never will never expire. Used to express the empty variant",
              "type": "object",
              "required": [
                "never"
              ],
              "properties": {
                "never": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "positions": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PositionsResponse",
      "type": "object",
      "required": [
        "positions"
      ],
      "properties": {
        "positions": {
          "description": "All the positions a user has.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Position"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Position": {
          "description": "Represents an LP position.",
          "type": "object",
          "required": [
            "identifier",
            "lp_asset",
            "open",
            "receiver",
            "unlocking_duration"
          ],
          "properties": {
            "expiring_at": {
              "description": "The block height at which the position, after being closed, can be withdrawn.",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint64",
              "minimum": 0.0
            },
            "identifier": {
              "description": "The identifier of the position.",
              "type": "string"
            },
            "lp_asset": {
              "description": "The amount of LP tokens that are put up to farm rewards.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "open": {
              "description": "If true, the position is open. If false, the position is closed.",
              "type": "boolean"
            },
            "receiver": {
              "description": "The owner of the position.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "unlocking_duration": {
              "description": "Represents the amount of time in seconds the user must wait after unlocking for the LP tokens to be released.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "rewards": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "RewardsResponse",
      "oneOf": [
        {
          "description": "The rewards response",
          "type": "object",
          "required": [
            "rewards_response"
          ],
          "properties": {
            "rewards_response": {
              "type": "object",
              "required": [
                "rewards_per_lp_denom",
                "total_rewards"
              ],
              "properties": {
                "rewards_per_lp_denom": {
                  "description": "The rewards per LP denom that is available to a user if they executed the `claim` function at this point.",
                  "type": "array",
                  "items": {
                    "type": "array",
                    "items": [
                      {
                        "type": "string"
                      },
                      {
                        "type": "array",
                        "items": {
                          "$ref": "#/definitions/Coin"
                        }
                      }
                    ],
                    "maxItems": 2,
                    "minItems": 2
                  }
                },
                "total_rewards": {
                  "description": "The rewards that is available to a user if they executed the `claim` function at this point.",
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Coin"
                  }
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Rewards response used internally when querying the rewards",
          "type": "object",
          "required": [
            "query_rewards_response"
          ],
          "properties": {
            "query_rewards_response": {
              "type": "object",
              "required": [
                "rewards"
              ],
              "properties": {
                "rewards": {
                  "description": "The rewards that is available to a user if they executed the `claim` function at this point.",
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Coin"
                  }
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "description": "Returned when claiming rewards",
          "type": "object",
          "required": [
            "claim_rewards"
          ],
          "properties": {
            "claim_rewards": {
              "type": "object",
              "required": [
                "modified_farms",
                "rewards"
              ],
              "properties": {
                "modified_farms": {
                  "description": "The rewards that were claimed on each farm, if any.",
                  "type": "object",
                  "additionalProperties": false
                },
                "rewards": {
                  "description": "The rewards that is available to a user if they executed the `claim` function at this point.",
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Coin"
                  }
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        }
      ],
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    }
  }
}
